<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Random Pattern AR</title>
    
    <!-- p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    
    <!-- MindAR + A-Frame -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            font-family: sans-serif;
        }
        
        #loading.hidden {
            display: none;
        }
        
        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-family: sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        
        /* p5.js 캔버스를 숨김 (텍스처로만 사용) */
        #p5-canvas-container {
            position: fixed;
            top: -9999px;
            left: -9999px;
        }
        
        /* AR 콘텐츠 스무딩 (CSS 레벨) */
        a-scene {
            will-change: transform;
        }
        
        [mindar-image-target] {
            transition: transform 0.1s ease-out;
            will-change: transform;
        }
    </style>
</head>
<body>
    <!-- 로딩 화면
    <div id="loading">
        <h2>AR 로딩 중...</h2>
        <p>잠시만 기다려주세요</p>
    </div> -->
    <!-- 안내 메시지 -->
    <div id="instructions">
        Stand By
    </div>
    
    <!-- p5.js 캔버스 컨테이너 (보이지 않음) -->
    <div id="p5-canvas-container"></div>
    
    <!-- AR Scene -->
    <a-scene
        mindar-image="imageTargetSrc: ./targets/targets.mind; filterMinCF:1.0; filterBeta: 10000; warmupTolerance: 10; missTolerance: 10; uiScanning: none; uiLoading: no;"
        color-space="sRGB"
        renderer="colorManagement: true, physicallyCorrectLights"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false">
        
        <!-- AR 콘텐츠: 포스터 인식 시 표시될 내용 -->
        <a-entity mindar-image-target="targetIndex: 0" smoothing="enabled: true; factor: 0.1;">
            <!-- p5.js 캔버스를 텍스처로 사용하는 평면 (A2 비율: 1:1.414) -->
            <a-plane 
                id="pattern-plane"
                position="0 0 0" 
                rotation="0 0 0"
                width="1" 
                height="1.414"
                material="shader: flat; transparent: true">
            </a-plane>
        </a-entity>
        
        <!-- 카메라 -->
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
    </a-scene>
    
    <!-- 스무딩 컴포넌트 (떨림 방지) - Moving Average -->
    <script>
        AFRAME.registerComponent('smoothing', {
            schema: {
                enabled: {type: 'boolean', default: true},
                factor: {type: 'number', default: 0.1}
            },
            
            init: function() {
                // Moving average를 위한 히스토리 저장
                this.positionHistory = [];
                this.rotationHistory = [];
                this.maxHistorySize = 10; // 지난 10 프레임 평균
                this.smoothedPosition = new THREE.Vector3();
                this.smoothedRotation = new THREE.Quaternion();
            },
            
            tick: function() {
                if (!this.data.enabled) return;
                
                const object3D = this.el.object3D;
                
                // 현재 위치/회전을 히스토리에 추가
                this.positionHistory.push(object3D.position.clone());
                this.rotationHistory.push(object3D.quaternion.clone());
                
                // 히스토리 크기 제한
                if (this.positionHistory.length > this.maxHistorySize) {
                    this.positionHistory.shift();
                    this.rotationHistory.shift();
                }
                
                // Position: 평균 계산
                this.smoothedPosition.set(0, 0, 0);
                for (let i = 0; i < this.positionHistory.length; i++) {
                    this.smoothedPosition.add(this.positionHistory[i]);
                }
                this.smoothedPosition.divideScalar(this.positionHistory.length);
                
                // Rotation: 마지막 몇 개만 부드럽게 (quaternion 평균은 복잡)
                const recentRotations = this.rotationHistory.slice(-3);
                this.smoothedRotation.copy(recentRotations[0]);
                for (let i = 1; i < recentRotations.length; i++) {
                    this.smoothedRotation.slerp(recentRotations[i], 1.0 / (i + 1));
                }
                
                // 적용
                object3D.position.copy(this.smoothedPosition);
                object3D.quaternion.copy(this.smoothedRotation);
            }
        });
    </script>
    
    <!-- p5.js 패턴 생성 스크립트 (sketch.js와 동일) -->
    <script src="../js/sketch.js"></script>
    
    <script>
        // AR용 setup 오버라이드
        let originalSetup = setup;
        setup = function() {
            // AR용 캔버스 생성 (800x1131을 AR 평면 비율에 맞게 조정)
            let canvas = createCanvas(800, 1131);
            canvas.parent('p5-canvas-container');
            background(0);
            noLoop();
            
            // SVG를 캔버스 중앙에 배치하기 위한 오프셋 계산
            svgOffsetX = (width - svgOriginalWidth * svgScale) / 2;
            svgOffsetY = (height - svgOriginalHeight * svgScale) / 2;
            
            // 패턴 자동 시작
            drawLineAcross();
            
            // A-Frame 평면에 캔버스 텍스처 적용
            setTimeout(() => {
                const plane = document.getElementById('pattern-plane');
                const canvas = document.querySelector('#p5-canvas-container canvas');
                if (plane && canvas) {
                    plane.setAttribute('material', {
                        shader: 'flat',
                        src: canvas,
                        transparent: false
                    });
                }
            }, 1000);
        };
        
        // 패턴 완성 상태 추적
        let patternCompleted = false;
        
        // AR용 draw 오버라이드 (텍스처 업데이트 추가)
        let originalDraw = draw;
        draw = function() {
            if (isDrawing) {
                // SVG 클리핑 적용 (캔버스 좌표계)
                drawingContext.save();
                
                // SVG 위치와 크기에 맞춰 변환 적용
                drawingContext.translate(svgOffsetX, svgOffsetY);
                drawingContext.scale(svgScale, svgScale);
                
                // 클리핑 패스 생성 및 적용
                let path = new Path2D(svgPath);
                drawingContext.clip(path);
                
                // 변환 취소 (점을 캔버스 좌표계로 그리기 위해)
                drawingContext.scale(1/svgScale, 1/svgScale);
                drawingContext.translate(-svgOffsetX, -svgOffsetY);
                
                // 모든 점 업데이트
                updateDot(1);
                updateDot(2);
                updateDot(3);
                updateDot(4);
                updateDot(5);
                updateDot(6);
                updateDot(7);
                updateDot(8);
                updateDot(9);
                updateDot(10);
                updateDot(11);
                updateDot(12);
                
                drawingContext.restore();
                
                // SVG 윤곽선을 최상단에 그리기
                drawingContext.save();
                drawingContext.translate(svgOffsetX, svgOffsetY);
                drawingContext.scale(svgScale, svgScale);
                let svgPath2 = new Path2D(svgPath);
                drawingContext.strokeStyle = '#000000';
                drawingContext.lineWidth = svgBorderWidth;
                drawingContext.lineCap = 'round';
                drawingContext.lineJoin = 'round';
                drawingContext.stroke(svgPath2);
                drawingContext.restore();
                
                // 패턴 완성도 계산 (진행률)
                const totalProgress = 
                    bounceCount1 / maxBounces1 +
                    bounceCount2 / maxBounces2 +
                    bounceCount3 / maxBounces3 +
                    bounceCount4 / maxBounces4 +
                    bounceCount5 / maxBounces5 +
                    bounceCount6 / maxBounces6 +
                    bounceCount7 / maxBounces7 +
                    bounceCount8 / maxBounces8 +
                    bounceCount9 / maxBounces9 +
                    bounceCount10 / maxBounces10 +
                    bounceCount11 / maxBounces11 +
                    bounceCount12 / maxBounces12;
                
                const progressPercent = Math.min(100, Math.round((totalProgress / 12) * 100));
                
                // 진행률 이벤트 발생 (매 프레임)
                window.dispatchEvent(new CustomEvent('patternProgress', { 
                    detail: { percent: progressPercent } 
                }));
                
                // 패턴 완성 체크
                const allDotsCompleted = 
                    bounceCount1 >= maxBounces1 &&
                    bounceCount2 >= maxBounces2 &&
                    bounceCount3 >= maxBounces3 &&
                    bounceCount4 >= maxBounces4 &&
                    bounceCount5 >= maxBounces5 &&
                    bounceCount6 >= maxBounces6 &&
                    bounceCount7 >= maxBounces7 &&
                    bounceCount8 >= maxBounces8 &&
                    bounceCount9 >= maxBounces9 &&
                    bounceCount10 >= maxBounces10 &&
                    bounceCount11 >= maxBounces11 &&
                    bounceCount12 >= maxBounces12;
                
                if (allDotsCompleted && !patternCompleted) {
                    patternCompleted = true;
                    // 커스텀 이벤트 발생
                    window.dispatchEvent(new CustomEvent('patternCompleted'));
                    console.log('✅ 패턴 완성!');
                }
                
                // A-Frame 텍스처 업데이트
                const plane = document.getElementById('pattern-plane');
                if (plane && plane.components.material && plane.components.material.material) {
                    const material = plane.components.material.material;
                    if (material.map) {
                        material.map.needsUpdate = true;
                    }
                }
            }
        };
    </script>
    
    <script>
        // AR Scene 이벤트
        const sceneEl = document.querySelector('a-scene');
        const loadingEl = document.getElementById('loading');
        const instructionsEl = document.getElementById('instructions');
        
        sceneEl.addEventListener('loaded', () => {
            loadingEl.classList.add('hidden');
        });
        
        const target = document.querySelector('[mindar-image-target]');
        
        target.addEventListener('targetFound', () => {
            console.log('포스터 인식됨!');
            instructionsEl.textContent = 'Random Accessing…';
            
            // 재인식 시 패턴 리셋
            if (typeof drawLineAcross === 'function') {
                patternCompleted = false; // 패턴 완성 플래그 초기화
                drawLineAcross();
            }
        });
        
        target.addEventListener('targetLost', () => {
            console.log('포스터 놓침');
            instructionsEl.textContent = 'Stand By';
        });
        
        // 패턴 진행률 이벤트 감지 (선택적)
        window.addEventListener('patternProgress', (e) => {
            const percent = e.detail.percent;
            // 진행률 표시 (원하면 활성화)
            // instructionsEl.textContent = `✨ Random access… ${percent}%`;
        });
        
        // 패턴 완성 이벤트 감지
        window.addEventListener('patternCompleted', () => {
            console.log('패턴 완성 감지!');
            instructionsEl.textContent = 'Access Complete';
            
            // 3초 후 메시지 변경 (선택적)
            setTimeout(() => {
                instructionsEl.textContent = 'Random Access Memory';
            }, 3000);
        });
    </script>
</body>
</html>

